/*
 * ELASTICSEARCH CONFIDENTIAL
 *
 * Copyright (c) 2016 Elasticsearch BV. All Rights Reserved.
 *
 * Notice: this software, and all information contained
 * therein, is the exclusive property of Elasticsearch BV
 * and its licensors, if any, and is protected under applicable
 * domestic and foreign law, and international treaties.
 *
 * Reproduction, republication or distribution without the
 * express written consent of Elasticsearch BV is
 * strictly prohibited.
 */
#ifndef INCLUDED_prelert_core_CDataAdder_h
#define INCLUDED_prelert_core_CDataAdder_h

#include <core/CNonCopyable.h>
#include <core/ImportExport.h>

#include <boost/function.hpp>
#include <boost/shared_ptr.hpp>

#include <iosfwd>
#include <string>

#include <stdint.h>


namespace prelert
{
namespace core
{

//! \brief
//! Abstract interface for data adder.
//!
//! DESCRIPTION:\n
//! Contains methods that require data be known in advance, plus a
//! method that returns a stream to which the data to be persisted
//! can be written.  This latter method is obviously much more
//! memory-efficient in cases where is is a viable option.
//!
//! IMPLEMENTATION DECISIONS:\n
//! There's an assumption that persisted state will be saved to a
//! data store that can retrieve based on 3 values: index, type
//! and ID.  Both the Splunk KV store and Elasticsearch support
//! this, and the scheme can also be made to fit non-REST API stores
//! such as a file system.  It can also be made to fit stores such
//! as Google Cloud Storage and Amazon S3, so is hopefully generic
//! enough for likely future requirements.
//!
class CORE_EXPORT CDataAdder : private CNonCopyable
{
    public:
        typedef boost::shared_ptr<std::ostream> TOStreamP;
        typedef boost::shared_ptr<CDataAdder>   TDataAdderP;

        typedef boost::function1<bool, CDataAdder &> TPersistFunc;

    public:
        virtual ~CDataAdder(void);

        //! Add streamed data - return of NULL stream indicates failure.
        //! Since the data to be written isn't known at the time this function
        //! returns it is not possible to detect all error conditions
        //! immediately.  If the stream goes bad whilst being written to then
        //! this also indicates failure.
        virtual TOStreamP addStreamed(const std::string &index,
                                      const std::string &type,
                                      const std::string &id) = 0;

        //! Clients that get a stream using addStreamed() must call this
        //! method one they've finished sending data to the stream.
        //! They should set force to true when the very last stream is
        //! complete, in case the persister needs to close off some
        //! sort of cached data structure.
        virtual bool streamComplete(TOStreamP &strm,
                                    bool force) = 0;

        //! The max number of documents that can go in a single
        //! batch save
        virtual std::size_t maxDocumentsPerBatchSave(void) const;

        //! The max size of a document - to be determined by the
        //! underlying storage medium
        virtual std::size_t maxDocumentSize(void) const;

        //! Get the default current document ID given a base ID and current
        //! document number.  The default ID is of the form
        //! baseId_currentDocNum if baseId is not empty, and simply
        //! currentDocNum converted to a string if baseId is empty.
        static std::string defaultCurrentDocId(const std::string &baseId,
                                                size_t currentDocNum);

        //! Give derived classes the opportunity to generate individual document
        //! IDs in a way that's different to the default.  The default IDs are
        //! generated by calling defaultCurrentDocId().
        virtual std::string makeCurrentDocId(const std::string &baseId,
                                             size_t currentDocNum) const;
};


}
}

#endif // INCLUDED_prelert_core_CDataAdder_h

