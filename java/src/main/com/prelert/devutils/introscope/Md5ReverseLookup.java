/************************************************************
 *                                                          *
 * Contents of file Copyright (c) Prelert Ltd 2006-2012     *
 *                                                          *
 *----------------------------------------------------------*
 *----------------------------------------------------------*
 * WARNING:                                                 *
 * THIS FILE CONTAINS UNPUBLISHED PROPRIETARY               *
 * SOURCE CODE WHICH IS THE PROPERTY OF PRELERT LTD AND     *
 * PARENT OR SUBSIDIARY COMPANIES.                          *
 * PLEASE READ THE FOLLOWING AND TAKE CAREFUL NOTE:         *
 *                                                          *
 * This source code is confidential and any person who      *
 * receives a copy of it, or believes that they are viewing *
 * it without permission is asked to notify Prelert Ltd     *
 * on +44 (0)20 3567 1249 or email to legal@prelert.com.    *
 * All intellectual property rights in this source code     *
 * are owned by Prelert Ltd.  No part of this source code   *
 * may be reproduced, adapted or transmitted in any form or *
 * by any means, electronic, mechanical, photocopying,      *
 * recording or otherwise.                                  *
 *                                                          *
 *----------------------------------------------------------*
 *                                                          *
 *                                                          *
 ***********************************************************/
package com.prelert.devutils.introscope;

import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.List;

import org.supercsv.io.CsvListReader;
import org.supercsv.prefs.CsvPreference;

/**
 * Takes the name of a csv file generated by the Introscope CLW. For
 * any resource strings that are longer than 127 chars the MD5 checksum
 * is calculated and its added the file 'rainbow_table.txt' which can
 * be used for a reverse look up.
 * 
 * Format is
 * 	digestValue=original string
 *
 *
 * Invoke the program with that command:
 * 	java -classpath ".:lib/*" com.prelert.devutils.introscope.Md5ReverseLookup filename.csv
 * 
 * The lib directory must contain the superCSV.jar file which 
 * is required for this program.
 *
 * The output file 'rainbow_table.txt' will be unsorted and contain duplicates
 * so run the bash command 'sort -u' to fix it.
 */
public class Md5ReverseLookup 
{
	@SuppressWarnings("unused")
	public static void main(String[] args) throws IOException
	{
		String filename = "";

		if (args.length > 0)
		{
			filename = args[0];
		}

		FileReader file = new FileReader(filename);

		FileWriter outFile = new FileWriter("rainbow_table.txt");

		System.out.println("Processing file... " + filename);

		CsvListReader csvReader = new CsvListReader(file, CsvPreference.EXCEL_PREFERENCE);		

        // Read the header
		List<String> line = csvReader.read();

		while ((line = csvReader.read()) != null)
		{
			try
			{
/*
 Domain,
 Host,
 Process,
 AgentName,
 Resource,
 MetricName,
 Record Type,
 Period,
 Intended End Timestamp,
 Actual Start Timestamp,
 Actual End Timestamp,
 Value Count,
 Value Type,
 Integer Value,
 Integer Min,
 Integer Max,
 Float Value,
 Float Min,
 Float Max,
 String Value,
 Date Value
*/

                // Example line
/*
SuperDomain/OLB,aolbmab00001003,WebSphere,cefs_OP03_01,JSP|_paybillsSessionCleanup,Concurrent Invocations,JSP Concurrent Invocations,60,Tue Mar 01 02:00:00 EST 2011,Tue Mar 01 00:00:00 EST 2011,Tue Mar 01 00:01:00 EST 2011,0,Integer,0,0,0,,,,,
*/
                // Check lengths


				String domainString = line.get(0);
				String hostString = line.get(1);
				String processString = line.get(2);
				String agentNameString = line.get(3);	
				String resourceString = line.get(4);
				String metricNameString = line.get(5);
				String recordTypeString = line.get(6);
				String periodString = line.get(7);
				String intendedEndTimeString = line.get(8);
				String actualStartTimeString = line.get(9);
				String actualEndTimeString = line.get(10);
				String valueCountString = line.get(11);
				String valueTypeString = line.get(12);
				String integerValueString = line.get(13);
				String integerMinString = line.get(14);
				String integerMaxString = line.get(15);
				String floatValueString = line.get(16);
				String floatMinString = line.get(17);
				String floatMaxString = line.get(18);
				String stringValueString = line.get(19);
				String dateValueString = line.get(20);

				processResourceString(resourceString, outFile);
                
            }
			catch (Exception e)
			{
                System.out.println(line);
                System.out.println(csvReader.getLineNumber());
				System.out.println(e);
				csvReader.read();
				continue;
			}

		}
		outFile.flush();
		outFile.close();
	}

    public static void processResourceString(String resourceString, 
    					FileWriter outfile) throws Exception
    {
        String [] resourceStrings = resourceString.split("\\|");
        
        if (resourceStrings.length > 8)
        {
            System.out.println("Long resource string " + resourceString);
            return;
        }
        for (int i = 0; i < resourceStrings.length; i++)
        {
            if (resourceStrings[i].length() > 127)
            {
                String digest = MD5(resourceStrings[i]);
                
                String table = digest + "=" + resourceStrings[i] + "\n";
                
                outfile.write(table);
            }
        }
    }

    private static String convertToHex(byte[] data) { 
        StringBuffer buf = new StringBuffer();
        for (int i = 0; i < data.length; i++) { 
            int halfbyte = (data[i] >>> 4) & 0x0F;
            int two_halfs = 0;
            do { 
                if ((0 <= halfbyte) && (halfbyte <= 9)) 
                    buf.append((char) ('0' + halfbyte));
                else 
                    buf.append((char) ('a' + (halfbyte - 10)));
                halfbyte = data[i] & 0x0F;
            } while(two_halfs++ < 1);
        } 
        return buf.toString();
    } 
 
    public static String MD5(String text) 
    throws NoSuchAlgorithmException, UnsupportedEncodingException  { 
        MessageDigest md;
        md = MessageDigest.getInstance("MD5");
        byte[] md5hash = new byte[32];
        md.update(text.getBytes("iso-8859-1"), 0, text.length());
        md5hash = md.digest();
        return convertToHex(md5hash);
    } 
}
